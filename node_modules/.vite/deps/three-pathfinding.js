import {
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Color,
  Line,
  LineBasicMaterial,
  Mesh,
  MeshBasicMaterial,
  Object3D,
  Plane,
  SphereGeometry,
  Triangle,
  Vector3
} from "./chunk-3F2VCGLV.js";

// node_modules/three-pathfinding/dist/three-pathfinding.module.js
var p = class {
  static roundNumber(t, e) {
    const r = Math.pow(10, e);
    return Math.round(t * r) / r;
  }
  static sample(t) {
    return t[Math.floor(Math.random() * t.length)];
  }
  static distanceToSquared(t, e) {
    var r = t.x - e.x, s = t.y - e.y, n = t.z - e.z;
    return r * r + s * s + n * n;
  }
  static isPointInPoly(t, e) {
    for (var r = false, s = -1, n = t.length, o = n - 1; ++s < n; o = s)
      (t[s].z <= e.z && e.z < t[o].z || t[o].z <= e.z && e.z < t[s].z) && e.x < (t[o].x - t[s].x) * (e.z - t[s].z) / (t[o].z - t[s].z) + t[s].x && (r = !r);
    return r;
  }
  static isVectorInPolygon(t, e, r) {
    var s = 1e5, n = -1e5, o = [];
    return e.vertexIds.forEach((t2) => {
      s = Math.min(r[t2].y, s), n = Math.max(r[t2].y, n), o.push(r[t2]);
    }), !!(t.y < n + 0.5 && t.y > s - 0.5 && this.isPointInPoly(o, t));
  }
  static triarea2(t, e, r) {
    return (r.x - t.x) * (e.z - t.z) - (e.x - t.x) * (r.z - t.z);
  }
  static vequal(t, e) {
    return this.distanceToSquared(t, e) < 1e-5;
  }
  static mergeVertices(r, s = 1e-4) {
    s = Math.max(s, Number.EPSILON);
    for (var n = {}, o = r.getIndex(), i = r.getAttribute("position"), h = o ? o.count : i.count, c = 0, a = [], u = [], l = Math.log10(1 / s), d = Math.pow(10, l), p2 = 0; p2 < h; p2++) {
      var g2 = o ? o.getX(p2) : p2, f2 = "";
      f2 += ~~(i.getX(g2) * d) + ",", f2 += ~~(i.getY(g2) * d) + ",", (f2 += ~~(i.getZ(g2) * d) + ",") in n ? a.push(n[f2]) : (u.push(i.getX(g2)), u.push(i.getY(g2)), u.push(i.getZ(g2)), n[f2] = c, a.push(c), c++);
    }
    const v2 = new BufferAttribute(new Float32Array(u), i.itemSize, i.normalized), b2 = new BufferGeometry();
    return b2.setAttribute("position", v2), b2.setIndex(a), b2;
  }
};
var g = class {
  constructor(t) {
    this.content = [], this.scoreFunction = t;
  }
  push(t) {
    this.content.push(t), this.sinkDown(this.content.length - 1);
  }
  pop() {
    const t = this.content[0], e = this.content.pop();
    return this.content.length > 0 && (this.content[0] = e, this.bubbleUp(0)), t;
  }
  remove(t) {
    const e = this.content.indexOf(t), r = this.content.pop();
    e !== this.content.length - 1 && (this.content[e] = r, this.scoreFunction(r) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e));
  }
  size() {
    return this.content.length;
  }
  rescoreElement(t) {
    this.sinkDown(this.content.indexOf(t));
  }
  sinkDown(t) {
    const e = this.content[t];
    for (; t > 0; ) {
      const r = (t + 1 >> 1) - 1, s = this.content[r];
      if (!(this.scoreFunction(e) < this.scoreFunction(s)))
        break;
      this.content[r] = e, this.content[t] = s, t = r;
    }
  }
  bubbleUp(t) {
    const e = this.content.length, r = this.content[t], s = this.scoreFunction(r);
    for (; ; ) {
      const n = t + 1 << 1, o = n - 1;
      let i, h = null;
      if (o < e && (i = this.scoreFunction(this.content[o]), i < s && (h = o)), n < e && this.scoreFunction(this.content[n]) < (null === h ? s : i) && (h = n), null === h)
        break;
      this.content[t] = this.content[h], this.content[h] = r, t = h;
    }
  }
};
var f = class {
  constructor() {
    this.portals = [];
  }
  push(t, e) {
    void 0 === e && (e = t), this.portals.push({ left: t, right: e });
  }
  stringPull() {
    const t = this.portals, e = [];
    let r, s, n, o = 0, i = 0, h = 0;
    r = t[0].left, s = t[0].left, n = t[0].right, e.push(r);
    for (let c = 1; c < t.length; c++) {
      const a = t[c].left, u = t[c].right;
      if (p.triarea2(r, n, u) <= 0) {
        if (!(p.vequal(r, n) || p.triarea2(r, s, u) > 0)) {
          e.push(s), r = s, o = i, s = r, n = r, i = o, h = o, c = o;
          continue;
        }
        n = u, h = c;
      }
      if (p.triarea2(r, s, a) >= 0) {
        if (!(p.vequal(r, s) || p.triarea2(r, n, a) < 0)) {
          e.push(n), r = n, o = h, s = r, n = r, i = o, h = o, c = o;
          continue;
        }
        s = a, i = c;
      }
    }
    return 0 !== e.length && p.vequal(e[e.length - 1], t[t.length - 1].left) || e.push(t[t.length - 1].left), this.path = e, e;
  }
};
var v = class {
  constructor() {
    this.zones = {};
  }
  static createZone(t, e = 1e-4) {
    return (class {
      static buildZone(t2, e2) {
        const s = this._buildNavigationMesh(t2, e2), n = {};
        s.vertices.forEach((t3) => {
          t3.x = p.roundNumber(t3.x, 2), t3.y = p.roundNumber(t3.y, 2), t3.z = p.roundNumber(t3.z, 2);
        }), n.vertices = s.vertices;
        const o = this._buildPolygonGroups(s);
        return n.groups = new Array(o.length), o.forEach((t3, e3) => {
          const s2 = /* @__PURE__ */ new Map();
          t3.forEach((t4, e4) => {
            s2.set(t4, e4);
          });
          const o2 = new Array(t3.length);
          t3.forEach((t4, e4) => {
            const i = [];
            t4.neighbours.forEach((t5) => i.push(s2.get(t5)));
            const h = [];
            t4.neighbours.forEach((e5) => h.push(this._getSharedVerticesInOrder(t4, e5)));
            const c = new Vector3(0, 0, 0);
            c.add(n.vertices[t4.vertexIds[0]]), c.add(n.vertices[t4.vertexIds[1]]), c.add(n.vertices[t4.vertexIds[2]]), c.divideScalar(3), c.x = p.roundNumber(c.x, 2), c.y = p.roundNumber(c.y, 2), c.z = p.roundNumber(c.z, 2), o2[e4] = { id: e4, neighbours: i, vertexIds: t4.vertexIds, centroid: c, portals: h };
          }), n.groups[e3] = o2;
        }), n;
      }
      static _buildNavigationMesh(t2, e2) {
        return t2 = p.mergeVertices(t2, e2), this._buildPolygonsFromGeometry(t2);
      }
      static _spreadGroupId(t2) {
        let e2 = /* @__PURE__ */ new Set([t2]);
        for (; e2.size > 0; ) {
          const r = e2;
          e2 = /* @__PURE__ */ new Set(), r.forEach((r2) => {
            r2.group = t2.group, r2.neighbours.forEach((t3) => {
              void 0 === t3.group && e2.add(t3);
            });
          });
        }
      }
      static _buildPolygonGroups(t2) {
        const e2 = [];
        return t2.polygons.forEach((t3) => {
          void 0 !== t3.group ? e2[t3.group].push(t3) : (t3.group = e2.length, this._spreadGroupId(t3), e2.push([t3]));
        }), e2;
      }
      static _buildPolygonNeighbours(t2, e2) {
        const r = /* @__PURE__ */ new Set(), s = e2[t2.vertexIds[1]], n = e2[t2.vertexIds[2]];
        return e2[t2.vertexIds[0]].forEach((e3) => {
          e3 !== t2 && (s.includes(e3) || n.includes(e3)) && r.add(e3);
        }), s.forEach((e3) => {
          e3 !== t2 && n.includes(e3) && r.add(e3);
        }), r;
      }
      static _buildPolygonsFromGeometry(t2) {
        const e2 = [], s = [], n = t2.attributes.position, o = t2.index, i = [];
        for (let t3 = 0; t3 < n.count; t3++)
          s.push(new Vector3().fromBufferAttribute(n, t3)), i[t3] = [];
        for (let r = 0; r < t2.index.count; r += 3) {
          const t3 = o.getX(r), s2 = o.getX(r + 1), n2 = o.getX(r + 2), h = { vertexIds: [t3, s2, n2], neighbours: null };
          e2.push(h), i[t3].push(h), i[s2].push(h), i[n2].push(h);
        }
        return e2.forEach((t3) => {
          t3.neighbours = this._buildPolygonNeighbours(t3, i);
        }), { polygons: e2, vertices: s };
      }
      static _getSharedVerticesInOrder(t2, e2) {
        const r = t2.vertexIds, s = r[0], n = r[1], o = r[2], i = e2.vertexIds, h = i.includes(s), c = i.includes(n), a = i.includes(o);
        return h && c && a ? Array.from(r) : h && c ? [s, n] : c && a ? [n, o] : h && a ? [o, s] : (console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."), []);
      }
    }).buildZone(t, e);
  }
  setZoneData(t, e) {
    this.zones[t] = e;
  }
  getRandomNode(t, e, s, n) {
    if (!this.zones[t])
      return new Vector3();
    s = s || null, n = n || 0;
    const o = [];
    return this.zones[t].groups[e].forEach((t2) => {
      s && n ? p.distanceToSquared(s, t2.centroid) < n * n && o.push(t2.centroid) : o.push(t2.centroid);
    }), p.sample(o) || new Vector3();
  }
  getClosestNode(t, e, r, s = false) {
    const n = this.zones[e].vertices;
    let o = null, i = Infinity;
    return this.zones[e].groups[r].forEach((e2) => {
      const r2 = p.distanceToSquared(e2.centroid, t);
      r2 < i && (!s || p.isVectorInPolygon(t, e2, n)) && (o = e2, i = r2);
    }), o;
  }
  findPath(t, e, s, n) {
    const o = this.zones[s].groups[n], i = this.zones[s].vertices, h = this.getClosestNode(t, s, n, true), c = this.getClosestNode(e, s, n, true);
    if (!h || !c)
      return null;
    const a = (class {
      static init(t2) {
        for (let e2 = 0; e2 < t2.length; e2++) {
          const r = t2[e2];
          r.f = 0, r.g = 0, r.h = 0, r.cost = 1, r.visited = false, r.closed = false, r.parent = null;
        }
      }
      static cleanUp(t2) {
        for (let e2 = 0; e2 < t2.length; e2++) {
          const r = t2[e2];
          delete r.f, delete r.g, delete r.h, delete r.cost, delete r.visited, delete r.closed, delete r.parent;
        }
      }
      static heap() {
        return new g(function(t2) {
          return t2.f;
        });
      }
      static search(t2, e2, r) {
        this.init(t2);
        const s2 = this.heap();
        for (s2.push(e2); s2.size() > 0; ) {
          const e3 = s2.pop();
          if (e3 === r) {
            let t3 = e3;
            const r2 = [];
            for (; t3.parent; )
              r2.push(t3), t3 = t3.parent;
            return this.cleanUp(r2), r2.reverse();
          }
          e3.closed = true;
          const n2 = this.neighbours(t2, e3);
          for (let t3 = 0, o2 = n2.length; t3 < o2; t3++) {
            const o3 = n2[t3];
            if (o3.closed)
              continue;
            const i2 = e3.g + o3.cost, h2 = o3.visited;
            if (!h2 || i2 < o3.g) {
              if (o3.visited = true, o3.parent = e3, !o3.centroid || !r.centroid)
                throw new Error("Unexpected state");
              o3.h = o3.h || this.heuristic(o3.centroid, r.centroid), o3.g = i2, o3.f = o3.g + o3.h, h2 ? s2.rescoreElement(o3) : s2.push(o3);
            }
          }
        }
        return [];
      }
      static heuristic(t2, e2) {
        return p.distanceToSquared(t2, e2);
      }
      static neighbours(t2, e2) {
        const r = [];
        for (let s2 = 0; s2 < e2.neighbours.length; s2++)
          r.push(t2[e2.neighbours[s2]]);
        return r;
      }
    }).search(o, h, c), u = function(t2, e2) {
      for (var r = 0; r < t2.neighbours.length; r++)
        if (t2.neighbours[r] === e2.id)
          return t2.portals[r];
    }, l = new f();
    l.push(t);
    for (let t2 = 0; t2 < a.length; t2++) {
      const e2 = a[t2], r = a[t2 + 1];
      if (r) {
        const t3 = u(e2, r);
        l.push(i[t3[0]], i[t3[1]]);
      }
    }
    l.push(e), l.stringPull();
    const d = l.path.map((t2) => new Vector3(t2.x, t2.y, t2.z));
    return d.shift(), d;
  }
};
v.prototype.getGroup = function() {
  const t = new Plane();
  return function(e, r, s = false) {
    if (!this.zones[e])
      return null;
    let n = null, o = Math.pow(50, 2);
    const i = this.zones[e];
    for (let e2 = 0; e2 < i.groups.length; e2++) {
      const h = i.groups[e2];
      for (const c of h) {
        if (s && (t.setFromCoplanarPoints(i.vertices[c.vertexIds[0]], i.vertices[c.vertexIds[1]], i.vertices[c.vertexIds[2]]), Math.abs(t.distanceToPoint(r)) < 0.01) && p.isPointInPoly([i.vertices[c.vertexIds[0]], i.vertices[c.vertexIds[1]], i.vertices[c.vertexIds[2]]], r))
          return e2;
        const h2 = p.distanceToSquared(c.centroid, r);
        h2 < o && (n = e2, o = h2);
      }
    }
    return n;
  };
}(), v.prototype.clampStep = function() {
  const t = new Vector3(), e = new Plane(), o = new Triangle(), i = new Vector3();
  let h, c, a = new Vector3();
  return function(r, s, n, u, l, d) {
    const p2 = this.zones[u].vertices, g2 = this.zones[u].groups[l], f2 = [n], v2 = {};
    v2[n.id] = 0, h = void 0, a.set(0, 0, 0), c = Infinity, e.setFromCoplanarPoints(p2[n.vertexIds[0]], p2[n.vertexIds[1]], p2[n.vertexIds[2]]), e.projectPoint(s, t), i.copy(t);
    for (let e2 = f2.pop(); e2; e2 = f2.pop()) {
      o.set(p2[e2.vertexIds[0]], p2[e2.vertexIds[1]], p2[e2.vertexIds[2]]), o.closestPointToPoint(i, t), t.distanceToSquared(i) < c && (h = e2, a.copy(t), c = t.distanceToSquared(i));
      const r2 = v2[e2.id];
      if (!(r2 > 2))
        for (let t2 = 0; t2 < e2.neighbours.length; t2++) {
          const s2 = g2[e2.neighbours[t2]];
          s2.id in v2 || (f2.push(s2), v2[s2.id] = r2 + 1);
        }
    }
    return d.copy(a), h;
  };
}();
var b = { PLAYER: new Color(15631215).convertSRGBToLinear().getHex(), TARGET: new Color(14469912).convertSRGBToLinear().getHex(), PATH: new Color(41903).convertSRGBToLinear().getHex(), WAYPOINT: new Color(41903).convertSRGBToLinear().getHex(), CLAMPED_STEP: new Color(14472114).convertSRGBToLinear().getHex(), CLOSEST_NODE: new Color(4417387).convertSRGBToLinear().getHex() };
var w = class extends Object3D {
  constructor() {
    super(), this._playerMarker = new Mesh(new SphereGeometry(0.25, 32, 32), new MeshBasicMaterial({ color: b.PLAYER })), this._targetMarker = new Mesh(new BoxGeometry(0.3, 0.3, 0.3), new MeshBasicMaterial({ color: b.TARGET })), this._nodeMarker = new Mesh(new BoxGeometry(0.1, 0.8, 0.1), new MeshBasicMaterial({ color: b.CLOSEST_NODE })), this._stepMarker = new Mesh(new BoxGeometry(0.1, 1, 0.1), new MeshBasicMaterial({ color: b.CLAMPED_STEP })), this._pathMarker = new Object3D(), this._pathLineMaterial = new LineBasicMaterial({ color: b.PATH, linewidth: 2 }), this._pathPointMaterial = new MeshBasicMaterial({ color: b.WAYPOINT }), this._pathPointGeometry = new SphereGeometry(0.08), this._markers = [this._playerMarker, this._targetMarker, this._nodeMarker, this._stepMarker, this._pathMarker], this._markers.forEach((t) => {
      t.visible = false, this.add(t);
    });
  }
  setPath(r) {
    for (; this._pathMarker.children.length; )
      this._pathMarker.children[0].visible = false, this._pathMarker.remove(this._pathMarker.children[0]);
    r = [this._playerMarker.position].concat(r);
    const s = new BufferGeometry();
    s.setAttribute("position", new BufferAttribute(new Float32Array(3 * r.length), 3));
    for (let t = 0; t < r.length; t++)
      s.attributes.position.setXYZ(t, r[t].x, r[t].y + 0.2, r[t].z);
    this._pathMarker.add(new Line(s, this._pathLineMaterial));
    for (let t = 0; t < r.length - 1; t++) {
      const e = new Mesh(this._pathPointGeometry, this._pathPointMaterial);
      e.position.copy(r[t]), e.position.y += 0.2, this._pathMarker.add(e);
    }
    return this._pathMarker.visible = true, this;
  }
  setPlayerPosition(t) {
    return this._playerMarker.position.copy(t), this._playerMarker.visible = true, this;
  }
  setTargetPosition(t) {
    return this._targetMarker.position.copy(t), this._targetMarker.visible = true, this;
  }
  setNodePosition(t) {
    return this._nodeMarker.position.copy(t), this._nodeMarker.visible = true, this;
  }
  setStepPosition(t) {
    return this._stepMarker.position.copy(t), this._stepMarker.visible = true, this;
  }
  reset() {
    for (; this._pathMarker.children.length; )
      this._pathMarker.children[0].visible = false, this._pathMarker.remove(this._pathMarker.children[0]);
    return this._markers.forEach((t) => {
      t.visible = false;
    }), this;
  }
};
export {
  v as Pathfinding,
  w as PathfindingHelper
};
//# sourceMappingURL=three-pathfinding.js.map
